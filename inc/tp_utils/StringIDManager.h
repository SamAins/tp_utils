#ifndef tp_utils_StringIDManager_h
#define tp_utils_StringIDManager_h

#include "tp_utils/Globals.h"

#include <boost/utility/string_ref.hpp>

#include <stdint.h>

#include <string>
#include <vector>

namespace tp_utils
{

class TP_UTILS_SHARED_EXPORT StringIDManager
{
public:
  //################################################################################################
  StringIDManager(const boost::string_ref& state=boost::string_ref(), bool rememberNew=false);

  //################################################################################################
  virtual ~StringIDManager();

  //################################################################################################
  //! Get the key for keyString
  /*!
  This should return the key for a given keyString, if it can't then it should return 0. Keys can be
  any number greater than 0. You can re-implement this to store keys in your data own store.

  \warning This must be thread safe!

  \param keyString - The string to produce the key for
  \return The key
  */
  virtual int64_t key(const std::string& keyString);

  //################################################################################################
  //! Get the keyString for key
  /*!
  This should return the keyString for a given key, if it can't then it should return an empty
  string. Keys can be any number greater than 0, and key strings can be any string at least one
  character long and containing alphanumeric characters, hyphens, and under scores. You can
  re-implement this to store keys in your own data store.

  \warning This must be thread safe!

  \param  key - The string to produce the key for
  \return The key string for key
  */
  virtual std::string keyString(int64_t key);

  //################################################################################################
  //! Save the state of the manager
  /*!
  If you are saving StringID's to file this can be used to create a dictionary that can be saved
  with the file. This will only work with this class and NOT with derrived classes.

  \warning - This will save the state of the base class only it is not intended to be used in
  derrived classes.

  \return - The state of this manager
  */
  std::string saveState()const;

  //################################################################################################
  std::vector<std::pair<std::string, int64_t>> takeNewSIDs();

  //################################################################################################
  //! Returns the size of the largest sid, for use with squashSIDs
  /*!
  Returns one of the following:
   - idSize=0 1byte used
   - idSize=1 2byte used
   - idSize=2 4byte used
   - idSize=3 8byte used
  */
  int sidSize();

  //################################################################################################
  //! Compact strings into a byte array
  /*!
  StringID's should only be made up of the following characters a->z, A->Z, 0->9, and ' '. Assuming
  that this is true we can compact the strings down to use 6 bits per character.

  \warning This method assumes that the strings are not empty, if one of the strings is empty
           expandStrings will truncate the list at that point.

  \param strings - The strings to compress.
  \return The serialized strings.
  */
  static std::string squashStrings(const std::vector<boost::string_ref>& strings);

  //################################################################################################
  //! Expand a list of strings
  /*!
  This is the reverse of squashStrings. If the data is directly generated by squashStrings() then
  offset should point to an integer containing 0, if the data starts with a header then the offset
  should be the index of first byte generated by squashStrings().

  \param data - The serialized strings generated by squashStrings()
  \param max - The maximum number of strings to extract.
  \param offset - The offset in the data to start from, set to the last char of the header.
  \return The list of strings.
  */
  static std::vector<std::string> expandStrings(const boost::string_ref& data, int max, int* offset);

  //################################################################################################
  //! Serialize a list of SIDs
  /*!
  This will serialize a list of sids, the strings will be packed into 6 bit characters and the IDs
  will be stored based on idSize:
   - idSize=0 1byte used
   - idSize=1 2byte used
   - idSize=2 4byte used
   - idSize=3 8byte used

  \param sids - The list of SIDs to serialize.
  \param idSize - The size to use for storing the IDs.
  */
  static std::string squashSIDs(const std::vector<std::pair<boost::string_ref, int64_t>>& sids, int idSize);

  //################################################################################################
  //! Expand a list of SIDs
  /*!
  This can be used to expand a list of SIDs previously squashed with squashSIDs().

  \param data - The data previously generated by squashSIDs().
  \param headerSize - This will be set to the size of the data used.
  \return The list of SIDs.
  */
  static std::vector<std::pair<std::string, int64_t>> expandSIDs(const boost::string_ref& data, int* headerSize);

private:
  struct Private;
  Private* d;
  friend struct Private;
};

}

#endif
